ЮНИТ 8.5.1
pm.test("Сохраняем номер телефона", function () {
    var jsonData = JSON.parse(responseBody)
    pm.collectionVariables.set("phone_1", jsonData.phone)
});

Данный код следует разбирать частями. Первая строка:

var jsonData = JSON.parse(responseBody)

Означает дословно следующее: «Объявляется переменная jsonData, 
которой присваивается значение в формате JSON(тело ответа)». 
Звучит заковыристо. Однако на деле это обозначает простую вещь: мы создаём новый объект, 
который будет содержать в себе тело ответа в формате JSON.

Следующая строка:

pm.collectionVariables.set("phone_1", jsonData.phone)

Данная строка означает: «В переменную коллекции записать («имя переменной — phone_1, что записать — ключ phone из объекта jsonData)».
__________________________________________________________________________________________________________________________________________

pm.test("В теле ответа содержится name_1", function () {
    pm.expect(pm.response.text()).to.include(pm.collectionVariables.get("name_1"));
});

Разберём значение скрипта, который мы написали: «ожидается(что текст ответа.содержит(значение переменной коллекции("name_1");»
___________________________________________________________________________________________________________________________________

pm.test("В теле ответа не содержится name_1", function () {
    pm.expect(pm.response.text()).to.not.include(pm.collectionVariables.get("name_1"));
});

Разберём подробнее строку нашего скрипта: «ожидается(что текст ответа.НЕ.содержит(значение переменной коллекции("name_1");».

Таким образом, мы заменили to на to.not, и теперь мы уже хотим «не найти» указанное в скобках 
выражение в тексте ответа после выполнения запроса.
______________________________________________________________________________________________________________________________________

pm.variables.set("phone_3", 456);

В отличие от предыдущих скриптов в данном случае мы использовали pm.variables.set конструкцию, а в скобках указали имя переменной, 
которую ранее нигде не объявляли. Такая запись является корректной.

Разница с pm.collectionVariables.set заключается в том, что используя последнее выражение, 
мы обращаемся к ранее объявленной переменной в рамках коллекции, и после выполнения запросов её значение будет сохранено. 
Сохранённое значение можно будет использовать при следующих прогонах либо внутри новых запросов в рамках коллекции.

Использование же pm.variables.set предполагает, что значение переменной будет храниться только во время выполнения запросов. 
Нам это подходит.

Таким образом, перед тем как отправить текущий запрос на сервер, система выполнит указанный выше скрипт из вкладки Pre-request Script, 
тем самым присвоит временной переменной phone_3 значение 456. 
Конечно, вы можете использовать любые другие названия переменных и цифровых значений.
______________________________________________________________________________________________________________________________________

pm.test("Сохранение id User 3 в переменную user_id", function() {
    var jsonData = JSON.parse(responseBody);
    pm.collectionVariables.set("user_id", jsonData.message);

Данный скрипт сохранит в переменную коллекции user_id значение ключа message из ответа от сервера.

Почему message хранит в себе id? Так продуман сервис разработчиками backend. 
Выполнение подобного запроса даёт ответ от сервера имеющий следующую структуру:
{
    "code": 200,
    "type": "unknown",
    "message": "9223372036854741535"
}

Ключ message содержит в себе строку с цифрами 6874991793 (значение может быть другим). 
При отправке следующего запроса на получение данных созданного пользователя мы увидим, что эти же цифры будут содержаться в значении ключа id. 
Однако к этому мы вернёмся позже, когда будем получать данные о созданном пользователе при выполнении следующего запроса.
Сейчас же нам важно понять, что ключ message в теле ответа после выполнения запроса содержит в себе id нового созданного пользователя.
____________________________________________________________________________________________________________________________________________
ЮНИТ 8.5.2
pm.test("Наличие ключа в ответе и запись его в перменную коллекции", function () {
    var jsonData = JSON.parse(responseBody);
    pm.expect(jsonData).to.have.all.keys('key');
    pm.collectionVariables.set("auth_key", jsonData.key);
});

Такой код проверит наличие ключа и установит значение переменной, если ключ есть.

Как вы уже заметили, в коде скрипта появилось новое ключевое слово expect. Данное слово является проверкой того, 
что следующее за ним выражение соответствует истине. Таким образом, строка pm.expect(jsonData).to.have.all.keys('key'); дословно читается так: 
«Ожидается, что ответ, находящийся в переменной jsonData, содержит в себе ключи с названием key».
_____________________________________________________________________________________________________________________________________________

pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
    var jsonData = JSON.parse(responseBody);
    pm.collectionVariables.set("petid", jsonData.id);
});

Если запрос на добавление успешно выполнился, то у нас есть ID питомца в ответе сервера. Добавленный код, позволяет использовать этот ID 
в дальнейших тестах.
_____________________________________________________________________________________________________________________________________________

Уже знакомая нам точка /api/pets?filter=my_pets (метод запроса GET) возвращает всех наших питомцев, а самых новых возвращает первыми, 
мы можем добавить простую проверку, что нулевой ([0]) элемент списка питомцев имеет ID и этот ID равен тому же ID, 
что вернул сервер после добавления питомца. Проверка выглядит так:

pm.test("first pets with new-created ID", function () {
    var jsonData = JSON.parse(responseBody);
    pm.expect(pm.collectionVariables.get("petid")).to.eql(jsonData.pets[0].id);
});

Дословно последняя строка скрипта читается так: «Ожидается, что переменная коллекции petid равна значению ID нулевого элемента списка pets 
из ответа от сервера».
_____________________________________________________________________________________________________________________________________________
